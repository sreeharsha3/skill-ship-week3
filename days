
day-1

1.gcd and lcm code

#include <iostream>
using namespace std;
long gcd(long,long); //declared

//def
long gcd(long a,long b){
    if(b==0){
        return a;
    }
    else{
        return gcd(b,a%b);
    }
}

int main() {
	int t;
	cin>>t;
	while(t--){
	    
	    long a,b,lcm,gcdd;
	    cin>>a>>b;
	    gcdd=gcd(a,b);
	    lcm=(a*b)/gcdd;
	    cout<<lcm<<" "<<gcdd<<endl;
	    
	}
	return 0;
}

2. sieve of eratosthenes code

#include <bits/stdc++.h>
using namespace std;

int main() {
	int t;
	cin>>t;
	while(t--){
	    int n,i,j,k,l;
	    cin>>n;
	    int primes[n+1];
	    for(i=0;i<=n;i++){
	        primes[i]=1;
	    }
	    primes[0]=0;
	    primes[1]=0;
	    for(j=2;j<=sqrt(n);j++){
	        if(primes[j]==1){
	            for(k=2;k*j<=n;k++){
	                primes[k*j]=0;
	            }
	        }
	    }
	    for(l=0;l<=n+1;l++){
	        if(primes[l]==1){
	            cout<<l<<" ";
	        }
	    }
	    cout<<endl;
	}
	return 0;
}

3. (a^b/c)%m code

#include <iostream>
using namespace std;
long long int d, z, y;
long long int modularExponentiation(long long int x,long long int n,long long int M)
{
    long long int result=1;
    while(n>0)
    {
        if(n % 2 ==1)
        result=(result * x)%M;
        x=(x*x)%M;
        n=n/2;
    }
    return result;
}
void extendedEuclid(long long int c,long long int m)
{
    if(m == 0)
    {
        d = c;
        z = 1;
        y = 0;
    }
    else
    {
        extendedEuclid(m, c%m);
        long long int temp = z;
        z = y;
        y = temp - (c/m)*y;
    }
}
long long int modInverse(int c, int M)
{
    extendedEuclid(c,M);
    return (z%M+M)%M;
}
int main()
{
    long long int a,b,c,m,ans1,ans2;
    cin>>a>>b>>c>>m;
    ans1=modularExponentiation(a,b,m);
    ans2=modInverse(c,m);
    cout<<((ans1%m)*(ans2%m))%m;
    return 0;
}



